#include <Arduino.h> // Aruduino
#include <MHZ19_uart.h> // CO2センサ ライブラリ
#include <Adafruit_Sensor.h> // センサ ライブラリ
#include <DHT.h> // 温湿度センサ ライブラリ
#include <DHT_U.h> // 温湿度センサ ライブラリ
#include <TFT_eSPI.h> // 液晶ディスプレ(ILI9341)ライブラリ
#include <SPI.h> // SPI ライブラリ
#include <WiFi.h>// WiFi ライブラリ
#include <ESPAsyncWebServer.h> // AsyncWebServer ライブラリ
#include <SPIFFS.h> // SPIFFS ライブラリ
#include <WebServer.h> // WebServer ライブラリ
#include <WebSocketsServer.h> // arduinoWebSockets ライブラリ
#include <elapsedMillis.h> // elapsedMillis ライブラリ
#include "index_html2.h" // web server root index
#include <sdfonts.h> // 液晶に日本語表示　ライブラリ
#include <ESP_Line_Notify.h> // Line_Notify ライブラリ

TFT_eSPI tft = TFT_eSPI();
#define DHT_Pin 32 // 温湿度センサピン 32
#define DHT_Type DHT11
#define SD_PN 15 // SDカードピン 15
DHT dht(DHT_Pin, DHT_Type);
double tempC; // 温度(℃)
double humid; // 湿度(%)
double co2ppm; // CO2濃度(ppm)
double dis; // 不快度指数
const int vol_pin = 33; // 感圧センサピン 33
int sensorValue = 0; // 感圧センサ 初期値
int j = 0;
int x = 0;
int xmin = 0;
int xmax = 60;
double ox, oy;
int i;
int k = 0;
char buf[16];
const int rx_pin = 16; // CO2センサ送信ピン 16
const int tx_pin = 17; // CO2センサ受信ピン 17
uint16_t t_x, t_y;
bool pressed;
MHZ19_uart mhz19;
SPIClass spiSD(HSPI);
const char *ssid_sta = "yourWiFi-ssid"; // WiFi_SSID
const char *password_sta = "yourWiFi-password"; // WiFi_password
const char *ssid_ap = "yourAP-ssid"; // AP_SSID
const char *password_ap = "yourAP-password"; // AP_password
AsyncWebServer server(80);
// Webサーバー
WebServer webServer(80); // 80番ポート
// Websocketサーバー
WebSocketsServer webSocket = WebSocketsServer(81); // 81番ポート
elapsedMillis sensorElapsed; // サンプリング周期
const unsigned long DELAY = 1000; // ms
File dataFile;
boolean display1 = true;
boolean display2 = true;
boolean display3 = true;
LineNotifyClient line;

// センサのデータ(JSON形式)
const char SENSOR_JSON[] PROGMEM = R"=====({"co2ppm":%.1f,"dis":%.1f,"tempC":%.1f,"humid":%.1f})=====";

// 日本語文字のBMP
const unsigned char ccc_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x03, 0x00, 0xF0, 0xFF, 0x07, 0x00, 0xFC, 0xFF, 0x07, 0x00, 0x7E, 0x00, 0x07, 0x00, 0x1F, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x1F, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x07, 0x00, 0xFE, 0xFF, 0x07, 0x00, 0xF8, 0xFF, 0x07, 0x00, 0xE0, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, };
const unsigned char ooo_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x3F, 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x80, 0xFF, 0xFF, 0x01, 0xC0, 0x0F, 0xF0, 0x03, 0xE0, 0x03, 0xC0, 0x07, 0xE0, 0x01, 0x80, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0x78, 0x00, 0x00, 0x1E, 0x78, 0x00, 0x00, 0x1E, 0x78, 0x00, 0x00, 0x1C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x38, 0x1C, 0x00, 0x00, 0x38, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x3C, 0x3C, 0x00, 0x00, 0x1C, 0x78, 0x00, 0x00, 0x1E, 0x78, 0x00, 0x00, 0x1E, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x01, 0x80, 0x0F, 0xE0, 0x03, 0xC0, 0x07, 0xC0, 0x0F, 0xF0, 0x03, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFC, 0x3F, 0x00, 0x00, 0xC0, 0x03, 0x00, };
const unsigned char sub_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0xE0, 0x3F, 0x00, 0x00, 0x70, 0x78, 0x00, 0x00, 0x30, 0x70, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x01, 0x00, 0xF8, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char onn_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x38, 0xF8, 0xFF, 0x07, 0x70, 0xF8, 0xFF, 0x07, 0xE0, 0x18, 0x00, 0x06, 0xC0, 0x18, 0x00, 0x06, 0x00, 0x18, 0x00, 0x06, 0x00, 0xF8, 0xFF, 0x07, 0x00, 0xF8, 0xFF, 0x07, 0x02, 0x18, 0x00, 0x06, 0x07, 0x18, 0x00, 0x06, 0x1E, 0x18, 0x00, 0x06, 0x38, 0x38, 0x00, 0x06, 0x70, 0xF8, 0xFF, 0x07, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x3F, 0x00, 0x8C, 0xE3, 0x18, 0x60, 0x0C, 0x63, 0x18, 0x60, 0x0C, 0x63, 0x18, 0x70, 0x0C, 0x63, 0x18, 0x30, 0x0C, 0x63, 0x18, 0x30, 0x0C, 0x63, 0x18, 0x18, 0x0C, 0x63, 0x18, 0x18, 0x0C, 0x63, 0x18, 0x1C, 0x0C, 0x63, 0x18, 0x8C, 0xFF, 0xFF, 0xFF, 0xCE, 0xFF, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char doo_bmp[] PROGMEM = {0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0xF0, 0xFF, 0xFF, 0x7F, 0xF0, 0xFF, 0xFF, 0xFF, 0x30, 0x00, 0x00, 0x00, 0x30, 0x60, 0xC0, 0x00, 0x30, 0x60, 0xC0, 0x00, 0x30, 0x60, 0xC0, 0x00, 0x30, 0x60, 0xC0, 0x00, 0xB0, 0xFF, 0xFF, 0x7F, 0x30, 0xE7, 0xE0, 0x70, 0x30, 0x60, 0xC0, 0x00, 0x30, 0x60, 0xC0, 0x00, 0x30, 0x60, 0xC0, 0x00, 0x30, 0xE0, 0xFF, 0x00, 0x30, 0xE0, 0xFF, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xFF, 0x03, 0x38, 0xFF, 0xFF, 0x07, 0x18, 0x30, 0x00, 0x03, 0x18, 0x60, 0x80, 0x01, 0x18, 0xE0, 0xC0, 0x01, 0x18, 0xC0, 0xE1, 0x00, 0x1C, 0x80, 0x7B, 0x00, 0x0C, 0x00, 0x1F, 0x00, 0x0E, 0x00, 0x3F, 0x00, 0x0E, 0xE0, 0xFB, 0x01, 0x06, 0xFE, 0xC0, 0x3F, 0xC6, 0x1F, 0x00, 0xFE, 0xC0, 0x01, 0x00, 0x60, };
const unsigned char deg_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x04, 0x10, 0x3C, 0xC0, 0x07, 0x08, 0x18, 0x24, 0xF0, 0x1F, 0x10, 0x0C, 0x42, 0x38, 0x18, 0x30, 0x04, 0x42, 0x18, 0x30, 0x20, 0x06, 0x24, 0x0C, 0x70, 0x60, 0x06, 0x18, 0x0C, 0x00, 0x40, 0x02, 0x00, 0x0C, 0x00, 0x40, 0x02, 0x00, 0x0E, 0x00, 0xC0, 0x02, 0x00, 0x06, 0x00, 0xC0, 0x02, 0x00, 0x06, 0x00, 0xC0, 0x02, 0x00, 0x0E, 0x00, 0xC0, 0x02, 0x00, 0x0E, 0x00, 0xC0, 0x02, 0x00, 0x0C, 0x00, 0x40, 0x06, 0x00, 0x0C, 0x60, 0x40, 0x04, 0x00, 0x1C, 0x30, 0x60, 0x0C, 0x00, 0x38, 0x38, 0x20, 0x08, 0x00, 0xF0, 0x1F, 0x30, 0x18, 0x00, 0xC0, 0x0F, 0x18, 0x30, 0x00, 0x00, 0x00, 0x08, 0x60, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char sit_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x38, 0xF8, 0xFF, 0x1F, 0x70, 0xF8, 0xFF, 0x1F, 0xE0, 0x18, 0x00, 0x18, 0xC0, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0xF8, 0xFF, 0x1F, 0x00, 0xF8, 0xFF, 0x1F, 0x06, 0x18, 0x00, 0x18, 0x1E, 0x18, 0x00, 0x18, 0x3C, 0x18, 0x00, 0x18, 0x70, 0x18, 0x00, 0x18, 0x20, 0xF8, 0xFF, 0x1F, 0x00, 0xF8, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x0C, 0x63, 0x30, 0x60, 0x0C, 0x43, 0x30, 0x60, 0x18, 0x43, 0x18, 0x70, 0x18, 0x43, 0x18, 0x30, 0x30, 0x43, 0x0C, 0x30, 0x30, 0x43, 0x0C, 0x38, 0x30, 0x43, 0x06, 0x18, 0x00, 0x63, 0x00, 0x1C, 0x00, 0x63, 0x00, 0x8C, 0xFF, 0xFF, 0xFF, 0x8E, 0xFF, 0xFF, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char kan_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFB, 0xFF, 0x1F, 0xFE, 0x1B, 0xC3, 0x10, 0x60, 0x18, 0xC2, 0x10, 0x60, 0x18, 0xC2, 0x10, 0x60, 0x18, 0xC3, 0x10, 0x60, 0xF8, 0xFF, 0x1F, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0xF8, 0xFF, 0x3F, 0xFC, 0xF9, 0xFF, 0x7F, 0xFC, 0x01, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0xF0, 0xFF, 0x0F, 0x60, 0xF0, 0xFF, 0x0F, 0x60, 0x30, 0x00, 0x0C, 0x60, 0x30, 0x00, 0x0C, 0x60, 0x30, 0x00, 0x0C, 0x60, 0xF2, 0xFF, 0x0F, 0xE0, 0x03, 0x3E, 0x30, 0xF0, 0x01, 0x7F, 0x38, 0x3E, 0x80, 0xD9, 0x0C, 0x0E, 0xC0, 0x99, 0x07, 0x00, 0x70, 0x18, 0x07, 0x00, 0x3C, 0x18, 0x1E, 0x00, 0x0F, 0x18, 0x78, 0x80, 0x03, 0x18, 0x70, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char kyou_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x60, 0x00, 0x18, 0x00, 0x60, 0x00, 0x18, 0x00, 0x60, 0x00, 0x18, 0x00, 0x60, 0xF8, 0xFF, 0x3F, 0x60, 0x00, 0x00, 0x00, 0x60, 0x80, 0x01, 0x03, 0x60, 0x80, 0x81, 0x01, 0x60, 0x00, 0x81, 0x01, 0x70, 0xF8, 0xFF, 0x7F, 0xFE, 0xFB, 0xFF, 0x7F, 0x70, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0xF0, 0xFF, 0x0F, 0x60, 0x70, 0x00, 0x0C, 0x60, 0x30, 0x00, 0x0C, 0x60, 0x70, 0x00, 0x0C, 0x60, 0xF0, 0xFF, 0x0F, 0x60, 0x30, 0x00, 0x0C, 0x60, 0x34, 0x00, 0x0C, 0x60, 0x37, 0x00, 0x0C, 0xE0, 0xF3, 0xFF, 0x0F, 0x7C, 0x00, 0xE3, 0x00, 0x1E, 0x00, 0x43, 0x00, 0x06, 0x80, 0x41, 0x00, 0x00, 0x80, 0x41, 0x60, 0x00, 0xC0, 0x40, 0x60, 0x00, 0xF0, 0xC0, 0x60, 0x00, 0x3C, 0xC0, 0x3F, 0x00, 0x1F, 0xC0, 0x1F, 0x00, 0x02, 0x00, 0x00, };
const unsigned char ten_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char ann_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0x3F, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x40, 0x00, 0x30, 0x0C, 0xE0, 0x00, 0x30, 0x0C, 0x60, 0x00, 0x30, 0x0C, 0x60, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0x00, 0x0C, 0xE0, 0x00, 0x00, 0x0E, 0x60, 0x00, 0x00, 0x06, 0x70, 0x00, 0x00, 0x07, 0x70, 0x00, 0x00, 0x03, 0x38, 0x00, 0x80, 0x0F, 0x18, 0x00, 0xC0, 0x7F, 0x1C, 0x00, 0xC0, 0xF0, 0x0F, 0x00, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0xE0, 0xF9, 0x00, 0x00, 0x7C, 0xC0, 0x03, 0x80, 0x1F, 0x80, 0x0F, 0xFC, 0x07, 0x00, 0x1E, 0x7C, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, };
const unsigned char zen_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x70, 0x0E, 0x00, 0x00, 0x38, 0x1C, 0x00, 0x00, 0x1C, 0x38, 0x00, 0x00, 0x0E, 0x70, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x80, 0x03, 0xC0, 0x03, 0xE0, 0x01, 0x00, 0x07, 0x78, 0x00, 0x00, 0x3E, 0x3C, 0xFF, 0xFF, 0x78, 0x0C, 0xFF, 0xFF, 0x20, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0xF8, 0xFF, 0xFF, 0x3F, 0xF8, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
const unsigned char kii_bmp[] PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xFC, 0x3F, 0x00, 0x00, 0x06, 0x38, 0x00, 0x00, 0x03, 0x18, 0x00, 0x80, 0x01, 0x08, 0x00, 0xC0, 0x00, 0x04, 0x00, 0x60, 0x00, 0x06, 0x00, 0x70, 0x00, 0x07, 0x00, 0xDC, 0xFF, 0xFF, 0x7F, 0xC4, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xFF, 0x01, 0xC0, 0x20, 0x00, 0x01, 0xC0, 0x20, 0x00, 0x01, 0xC0, 0x20, 0x00, 0x01, 0x40, 0x20, 0x00, 0x01, 0x40, 0x20, 0x80, 0x01, 0x40, 0x20, 0x80, 0x01, 0x60, 0x20, 0xF8, 0x00, 0x60, 0x20, 0x00, 0x00, 0x20, 0x20, 0x00, 0x20, 0x30, 0x20, 0x00, 0x20, 0x30, 0x20, 0x00, 0x20, 0x18, 0x20, 0x00, 0x30, 0x0C, 0xE0, 0x00, 0x1C, 0x0C, 0xC0, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, };
const unsigned char ken_bmp[] PROGMEM = {0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xFE, 0x03, 0x3C, 0x00, 0xFE, 0x07, 0x7E, 0x00, 0x06, 0x03, 0xE7, 0x00, 0x06, 0x83, 0xC3, 0x01, 0x86, 0xC1, 0x81, 0x07, 0x86, 0xF1, 0x00, 0x1E, 0xC6, 0x78, 0x00, 0x7C, 0xC6, 0xDE, 0xFF, 0x73, 0xE6, 0x8E, 0x39, 0x43, 0x66, 0x00, 0x18, 0x00, 0x66, 0x00, 0x18, 0x00, 0xE6, 0x00, 0x18, 0x00, 0xC6, 0xF0, 0xFF, 0x1F, 0x86, 0x31, 0x18, 0x1C, 0x86, 0x31, 0x18, 0x18, 0x06, 0x33, 0x18, 0x18, 0x06, 0x33, 0x18, 0x18, 0x06, 0x33, 0x18, 0x18, 0x06, 0xF3, 0xFF, 0x1F, 0x06, 0xF3, 0xFF, 0x1F, 0x86, 0x03, 0x3C, 0x00, 0xE6, 0x01, 0x3E, 0x00, 0x66, 0x00, 0x66, 0x00, 0x06, 0x00, 0xC3, 0x00, 0x06, 0x80, 0x83, 0x01, 0x06, 0xC0, 0x01, 0x07, 0x06, 0xF0, 0x00, 0x0E, 0x06, 0x3E, 0x00, 0x7C, 0x06, 0x0F, 0x00, 0x70, 0x04, 0x02, 0x00, 0x00, };

// 測定開始
void sensor_start()
{
  // ----- センサからデータ取得 -----
  co2ppm = mhz19.getCO2PPM(); //CO2濃度
  tempC = dht.readTemperature(); //温度
  humid = dht.readHumidity(); //湿度
  dis = 0.81 * tempC + 0.01 * humid * (0.99 * tempC - 14.3) + 46.3; //不快指数
  sensorValue = analogRead(vol_pin); //圧力センサ
  Serial.print("\nCO2: ");
  Serial.println(co2ppm);
  Serial.print("discomfort index: ");
  Serial.println(dis);
  Serial.print("temp: ");
  Serial.println(tempC);
  Serial.print("humib: ");
  Serial.println(humid);
  Serial.print("sensorvalue: ");
  Serial.println(sensorValue);

  // SDカードのdata.csvに書き込み
  k++; //書き込み回数
  char dat[32];
  memset(dat, sizeof(dat), 0x00);
  sprintf(dat, "%4.2f,%4.2f,%4.2f,%4.2f", co2ppm, tempC, humid, dis);
  dataFile = SD.open("/data.csv", FILE_APPEND);
  dataFile.println(dat);
  dataFile.close();
  if (k == 180) // 書き込み回数が180回だとファイルを作り直す
  {
    SD.remove("/data.csv");
    dataFile = SD.open("/data.csv", FILE_WRITE);
    dataFile.println("File Written");
    dataFile.close();
    k = 0;
  }
}

// ディスプレイのタッチ判定
void checkTouched()
{
  t_x = 0;
  t_y = 0;
  pressed = tft.getTouch(&t_x, &t_y);
}

// 測定結果のディスプレイ表示
void sensor_display()
{
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  // ----- 項目名を日本語で表示 -----
  // CO2(ppm)
  tft.drawXBitmap(5, 17, ccc_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(40, 17, ooo_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(74, 25, sub_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(94, 17, ten_bmp, 32, 32, TFT_WHITE);
  tft.drawString("(ppm)", 250, 32, 4);
  // 温度(℃)
  tft.drawXBitmap(10, 67, onn_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(42, 67, doo_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(94, 67, ten_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(250, 67, deg_bmp, 40, 40, TFT_WHITE);
  // 湿度(%)
  tft.drawXBitmap(10, 117, sit_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(42, 117, doo_bmp, 32, 32, TFT_WHITE);
  tft.drawXBitmap(94, 117, ten_bmp, 32, 32, TFT_WHITE);
  tft.drawString("(%)", 250, 127, 4);
  // 環境:
  tft.drawXBitmap(10, 167, kan_bmp, 32, 32, TFT_GREEN);
  tft.drawXBitmap(42, 167, kyou_bmp, 32, 32, TFT_GREEN);
  tft.drawXBitmap(94, 167, ten_bmp, 32, 32, TFT_GREEN);
  // ----- 液晶画面に気圧、温度、湿度の測定値、IPを表示 -----
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.drawFloat(co2ppm, 0, 140, 17, 6);
  tft.drawFloat(tempC, 1, 140, 67, 6);
  tft.drawFloat(humid, 1, 140, 117, 6);
  if (WiFi.status() != WL_CONNECTED)
  {
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawString("AP with IP Gateway :", 10, 215, 2);
    tft.drawString(buf, 140, 215, 2);
  }
  else
  {
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawString("WiFi network with local IP : ", 10, 215, 2);
    tft.drawString(buf, 185, 215, 2);
  }
  if (co2ppm >= 1300 || dis >= 70 || dis <= 60)
  {
    // 危険
    tft.drawXBitmap(140, 167, kii_bmp, 32, 32, TFT_RED);
    tft.drawXBitmap(172, 167, ken_bmp, 32, 32, TFT_RED);
  }
  else
  {
    // 安全
    tft.drawXBitmap(140, 167, ann_bmp, 32, 32, TFT_GREEN);
    tft.drawXBitmap(172, 167, zen_bmp, 32, 32, TFT_GREEN);
  }
  delay(1000); // 測定間隔
  tft.fillRect(140, 17, 110, 200, TFT_BLACK);
}

// WebSocket用のCO2測定
String readCo2ppm()
{
  if (isnan(co2ppm))
  {
    Serial.println("Failed to read from MHZ19 sensor!");
    return "";
  }
  else
  {
    Serial.println(co2ppm);
    return String(co2ppm);
  }
}

// WebSocket用の不快度指数
String readDiscomfort()
{
  if (isnan(dis))
  {
    Serial.println("Failed to read!");
    return "";
  }
  else
  {
    Serial.println(dis);
    return String(dis);
  }
}

// WebSocket用の温度測定
String readTemperature()
{
  if (isnan(tempC))
  {
    Serial.println("Failed to read from DHT11 sensor!");
    return "";
  }
  else
  {
    Serial.println(tempC);
    return String(tempC);
  }
}

// WebSocket用の湿度測定
String readHumidity()
{
  if (isnan(humid))
  {
    Serial.println("Failed to read from DHT11 sensor!");
    return "";
  }
  else
  {
    Serial.println(humid);
    return String(humid);
  }
}

// データの更新
void sensor_loop()
{
  char payload[200];
  // (4) センシング
  snprintf_P(payload, sizeof(payload), SENSOR_JSON, co2ppm, dis, tempC, humid);
  // WebSocketでデータ送信(全端末へブロードキャスト)
  webSocket.broadcastTXT(payload, strlen(payload));
  Serial.println(payload);
}

void handleRoot()
{
  String s2 = INDEX_HTML2; // index_html2.hより読み込み
  webServer.send(200, "text/html", s2);
}

void handleNotFound()
{
  webServer.send(404, "text/plain", "File not found.");
}

// ディスプレイにグラフの表示
void Graph(double x, double y, double gx, double gy, double w, double h, double xlo, double xhi, double xinc, double ylo, double yhi, double yinc, String title, String xlabel, String ylabel, unsigned int gcolor, unsigned int acolor, unsigned int pcolor, unsigned int tcolor, unsigned int bcolor, boolean &redraw)
{

  double ydiv, xdiv;
  // initialize old x and old y in order to draw the first point of the graph
  // but save the transformed value
  // note my transform funcition is the same as the map function, except the map uses long and we need doubles
  // static double ox = (x - xlo) * ( w) / (xhi - xlo) + gx;
  // static double oy = (y - ylo) * (gy - h - gy) / (yhi - ylo) + gy;
  double i;
  double temp;
  int rot, newrot;

  if (redraw == true)
  {

    redraw = false;
    ox = (x - xlo) * (w) / (xhi - xlo) + gx;
    oy = (y - ylo) * (gy - h - gy) / (yhi - ylo) + gy;
    // draw y scale
    for (i = ylo; i <= yhi; i += yinc)
    {
      // compute the transform
      temp = (i - ylo) * (gy - h - gy) / (yhi - ylo) + gy;

      if (i == 0)
      {
        tft.drawLine(gx, temp, gx + w, temp, acolor);
      }
      else
      {
        tft.drawLine(gx, temp, gx + w, temp, gcolor);
      }

      tft.setTextSize(1);
      tft.setTextColor(tcolor, bcolor);
      tft.setCursor(gx - 20, temp);
      // precision is default Arduino--this could really use some format control
      int ay = i;
      // d.println(i);
      tft.println(ay);
    }
    // draw x scale
    for (i = xlo; i <= xhi; i += xinc)
    {

      // compute the transform

      temp = (i - xlo) * (w) / (xhi - xlo) + gx;
      if (i == 0)
      {
        tft.drawLine(temp, gy, temp, gy - h, acolor);
      }
      else
      {
        tft.drawLine(temp, gy, temp, gy - h, gcolor);
      }

      tft.setTextSize(1);
      tft.setTextColor(tcolor, bcolor);
      tft.setCursor(temp - 5, gy + 10);
      // precision is default Arduino--this could really use some format control
      int ax = i;
      tft.println(ax);
    }

    // now draw the labels
    tft.setTextSize(2);
    tft.setTextColor(tcolor, bcolor);
    tft.setCursor(gx, gy - h - 30);
    tft.println(title);

    tft.setTextSize(1);
    tft.setTextColor(acolor, bcolor);
    tft.setCursor(gx, gy + 20);
    tft.println(xlabel);

    tft.setTextSize(1);
    tft.setTextColor(acolor, bcolor);
    tft.setCursor(gx - 30, gy - h - 10);
    tft.println(ylabel);
  }

  // graph drawn now plot the data
  //  the entire plotting code are these few lines...
  //  recall that ox and oy are initialized as static above
  x = (x - xlo) * (w) / (xhi - xlo) + gx;
  y = (y - ylo) * (gy - h - gy) / (yhi - ylo) + gy;
  tft.drawLine(ox, oy, x, y, pcolor);
  tft.drawLine(ox, oy + 1, x, y + 1, pcolor);
  tft.drawLine(ox, oy - 1, x, y - 1, pcolor);
  ox = x;
  oy = y;
}

// フォントデータの表示
// buf(in) : フォント格納アドレス
// ビットパターン表示
// d: 8ビットパターンデータ
void fontDisp(uint16_t x, uint16_t y, uint8_t* buf) {
  // 白地に黒の字で表示するようにしています。
  // カラーコードを引数で与える様にすれば行、或いは文字毎に色が変えられそうです
  uint32_t txt_color = TFT_RED;
  uint32_t bg_color = TFT_BLACK;

  uint8_t bn = SDfonts.getRowLength();               // 1行当たりのバイト数取得
//  Serial.print(SDfonts.getWidth(), DEC);            // フォントの幅の取得
//  Serial.print("x");
//  Serial.print(SDfonts.getHeight(), DEC);           // フォントの高さの取得
//  Serial.print(" ");
//  Serial.println((uint16_t)SDfonts.getCode(), HEX); // 直前し処理したフォントのUTF16コード表示

  for (uint8_t i = 0; i < SDfonts.getLength(); i += bn ) {
    for (uint8_t j = 0; j < bn; j++) {
      for (uint8_t k = 0; k < 8; k++) {
        if (buf[i + j] & 0x80 >> k) {
          tft.drawPixel(x + 8 * j + k , y + i / bn, txt_color);
        } else {
          tft.drawPixel(x + 8 * j + k , y + i / bn, bg_color);
        }
      }
    }
  }
}


// 指定した文字列を指定したサイズで表示する
// pUTF8(in) UTF8文字列
// sz(in)    フォントサイズ(8,10,12,14,16,20,24)
void fontDump(uint16_t x, uint16_t y, char* pUTF8, uint8_t sz) {
  uint8_t buf[MAXFONTLEN]; // フォントデータ格納アドレス(最大24x24/8 = 72バイト)
  SDfonts.open();                                   // フォントのオープン
  SDfonts.setFontSize(sz);                          // フォントサイズの設定
  uint16_t mojisu = 0;
  while ( pUTF8 = SDfonts.getFontData(buf, pUTF8) ) { // フォントの取得
    fontDisp(x + mojisu * sz, y, buf);                 // フォントパターンの表示
    ++mojisu;
  }

  SDfonts.close();                                  // フォントのクローズ
}

//LINE通知
void line_message()
{
  if (co2ppm >= 1300 || dis >= 70 || dis <= 60)
  {
    line.message = "\n二酸化炭素濃度: " + String(co2ppm)  + "(ppm)\n" + "温度: " + String(tempC) + "(℃)\n" + "湿度: " + String(humid) + "(%)\n" + "危険な環境です。" ;
    LineNotifySendingResult result = LineNotify.send(line);
  }
  else
  {
    delay(1000);
  }
}

void setup(void)
{
  Serial.begin(115200);
  // 温湿度センサ初期化
  dht.begin();

  // TFT液晶初期化
  tft.init();
  tft.setRotation(3);
  tft.setTextSize(1);
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.drawString("Sensor is warming up now.", 0, 20, 4);
  pressed = false;

  // CO2センサ初期化
  mhz19.begin(rx_pin, tx_pin);
  mhz19.setAutoCalibration(false); // キャリブレーションOFF
  Serial.println("Sensor is warming up now.");

  // SDカード初期化
  tft.drawString("Initializing SD library & card", 0, 40, 4);
  delay(2000);
  tft.fillScreen(TFT_BLACK);
  spiSD.begin(14, 12, 13, SD_PN); // SCK,MISO,MOSI,CS
  while (!SD.begin(15, spiSD)) // SDカードマウントできない間
  {
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.drawString("Card Mount Failed", 0, 20, 4);
    delay(2000);
    tft.fillScreen(TFT_BLACK);
  }
  // SDカードマウント成功すると
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.drawString("Card Mount Successful", 0, 20, 4);
  SDfonts.init(SD_PN);
  Serial.println(F("sdfonts liblary"));
  delay(2000); // 安定するまで2秒ほど待つ
  tft.fillScreen(TFT_BLACK);
  dataFile = SD.open("/data.csv", FILE_WRITE); // SDカードファイル書き込み
  dataFile.println("File Written");
  dataFile.close();

  //  Initialize SPIFFS
  if (!SPIFFS.begin())
  {
    Serial.println("An Error has occurred while mounting SPIFFS");
    return;
  }

  // WiFiに繋げる
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid_sta, password_sta);
  Serial.print("\n[*] Connecting to WiFi Network");
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString("[*]Connecting to WiFi Network", 0, 0, 2);
  for (i = 0; i <= 5; i = i + 1) //5秒間WiFiルーターを探す
  {
    if (WiFi.status() != WL_CONNECTED)
    {
      delay(1000);
      Serial.print(".");
      tft.drawString(".", 190 + i * 5, 0, 2);
    }
    else // 5秒以内にWiFiルーターに繋がった場合
    {
      Serial.print("\n[+] Connected to WiFi network with local IP : ");
      tft.drawString("[+] Connected to WiFi network with local IP : ", 0, 20, 2);
      Serial.println(WiFi.localIP()); // Route for root / web page
      sprintf(buf, "%d.%d.%d.%d", WiFi.localIP()[0], WiFi.localIP()[1], WiFi.localIP()[2], WiFi.localIP()[3]);
      tft.drawString(buf, 220, 40, 2);
      delay(2000);

      server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/index.html"); });
      server.on("/game.html", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/game.html", "text/html"); });
      server.on("/game.js", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/game.js", "text/javascript"); });
      server.on("/player.png", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/player.png", "image/png"); });
      server.on("/enemy.png", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/enemy.png", "image/png"); });
      server.on("/moon.png", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/moon.png", "image/png"); });
      server.on("/tree.png", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send(SPIFFS, "/tree.png", "image/png"); });
      server.on("/co2ppm", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send_P(200, "text/plain", readCo2ppm().c_str()); });
      server.on("/discomfort", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send_P(200, "text/plain", readDiscomfort().c_str()); });
      server.on("/temperature", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send_P(200, "text/plain", readTemperature().c_str()); });
      server.on("/humidity", HTTP_GET, [](AsyncWebServerRequest *request)
                { request->send_P(200, "text/plain", readHumidity().c_str()); });
      server.begin(); // Webサーバー開始
      line.token = "your-LINEtoken"; // LINEトークンの入力
      break;
    }
    if (i == 5) // 5秒間待ってもWiFiルータに繋がらない場合、アクセスポイント作成
    {
      Serial.println("Connection Failed to WiFI.");
      WiFi.disconnect();
      tft.drawString("Connection Failed to WiFI.", 0, 20, 2);
      Serial.println("\n[*] Creating ESP32 AP");
      tft.drawString("[*] Creating ESP32 AP", 0, 60, 2);
      delay(DELAY);
      WiFi.mode(WIFI_AP);
      WiFi.softAP(ssid_ap, password_ap);
      Serial.print("[+] AP Created with IP Gateway :");
      tft.drawString("[+] AP Created with IP Gateway :", 0, 80, 2);
      Serial.println(WiFi.softAPIP());
      sprintf(buf, "%d.%d.%d.%d", WiFi.softAPIP()[0], WiFi.softAPIP()[1], WiFi.softAPIP()[2], WiFi.softAPIP()[3]);
      tft.drawString(buf, 205, 80, 2);
      delay(2000);

      webServer.serveStatic("/favicon.ico", SPIFFS, "/favicon.ico");
      webServer.serveStatic("/Chart.min.js", SPIFFS, "/Chart.min.js");
      webServer.on("/", handleRoot);
      webServer.onNotFound(handleNotFound);
      webServer.begin(); // Webサーバー開始
      webSocket.begin(); // WebSocketサーバー開始
      break;
    }
  }
  tft.fillScreen(TFT_BLACK);
}

void loop()
{
  while (j == 0) // 液晶ディスプレイ(ILI9341)に1番目に表示される画面(測定値と環境が危険か安全かの表示)
  {
    sensor_start();
    checkTouched();
    sensor_display();
    if (WiFi.status() != WL_CONNECTED) // WiFiに繋がっていない場合(アクセスポイント作成時)
    {
      webSocket.loop();
      webServer.handleClient();
      // 一定の周期でセンシング
      if (sensorElapsed > DELAY)
      {
        sensorElapsed = 0;
        sensor_loop();
      }
    }
    else // WiFiに繋がっている場合
    {
      line_message();
    }

    if (sensorValue < 2250 || pressed) // 感圧センサか液晶ディスプレイ(ILI9341)が押された場合
    {
      pressed = false;
      x = 0;
      xmin = 0;
      xmax = 60;
      j++;
      Serial.println("画面切り替え");
      delay(3000);
      tft.fillScreen(TFT_BLACK);
      delay(1000);
      fontDump(120, 10, "二酸化炭素の濃度", 16);
      break;
    }
  }

  while (j == 1) // 液晶ディスプレイ(ILI9341)に表示される2番目に表示される画面(CO2濃度のグラフを表示)
  {
    sensor_start();
    checkTouched();

    if (WiFi.status() != WL_CONNECTED) // WiFiに繋がっていない場合(アクセスポイント作成時)
    {
      webSocket.loop();
      webServer.handleClient();
      // 一定の周期でセンシング
      if (sensorElapsed > DELAY)
      {
        sensorElapsed = 0;
        sensor_loop();
      }
      delay(1000);
    }
    else // WiFiに繋がっている場合
    {
      line_message();
    }

    // グラフを表示
    if (x < xmax)
    {
      x++;
    }
    else
    {
      xmin = xmax;
      xmax = xmax + 60;
      display1 = true;
      tft.fillScreen(TFT_BLACK);
      delay(500);
      fontDump(120, 10, "二酸化炭素の濃度", 16);
    }
    if (x == 240)
    {
      x = 0;
      xmin = 0;
      xmax = 60;
      display1 = true;
      tft.fillScreen(TFT_BLACK);
      fontDump(120, 10, "二酸化炭素の濃度", 16);
    }
    Graph(x, co2ppm / 10, 30, 210, 270, 180, xmin, xmax, 10, 0, 250, 25, "", " Time [s]", "CO2 * 10[ppm]", TFT_DARKGREY, TFT_RED, TFT_GREEN, TFT_WHITE, TFT_BLACK, display1);

    if (sensorValue < 2250 || pressed) // 感圧センサか液晶ディスプレイ(ILI9341)が押された場合
    {
      pressed = false;
      x = 0;
      xmin = 0;
      xmax = 60;
      display1 = true;
      j++;
      Serial.println("画面切り替え");
      delay(3000);
      tft.fillScreen(TFT_BLACK);
      delay(1000);
      fontDump(160, 10, "温度", 20);
      fontDump(0, 10, "温度[℃]", 16);
      break;
    }
  }

  while (j == 2)  // 液晶ディスプレイ(ILI9341)に表示される3番目に表示される画面(温度のグラフを表示)
  {
    sensor_start();
    checkTouched();

    if (WiFi.status() != WL_CONNECTED) // WiFiに繋がっていない場合(アクセスポイント作成時)
    {
      webSocket.loop();
      webServer.handleClient();
      // 一定の周期でセンシング
      if (sensorElapsed > DELAY)
      {
        sensorElapsed = 0;
        sensor_loop();
      }
      delay(1000);
    }
    else // WiFiに繋がっている場合
    {
      line_message();
    }

    //グラフを表示
    if (x < xmax)
    {
      x++;
    }
    else
    {
      xmin = xmax;
      xmax = xmax + 60;
      display2 = true;
      tft.fillScreen(TFT_BLACK);
      delay(500);
      fontDump(160, 10, "温度", 20);
      fontDump(0, 10, "温度[℃]", 16);
    }
    if (x == 240)
    {
      x = 0;
      xmin = 0;
      xmax = 60;
      display2 = true;
      tft.fillScreen(TFT_BLACK);
      fontDump(160, 10, "温度", 20);
      fontDump(0, 10, "温度[℃]", 16);
    }
    Graph(x, tempC, 30, 210, 270, 180, xmin, xmax, 10, 0, 50, 10, "", " Time [s]", "", TFT_DARKGREY, TFT_RED, TFT_GREEN, TFT_WHITE, TFT_BLACK, display2);

    if (sensorValue < 2250 || pressed)  // 感圧センサか液晶ディスプレイ(ILI9341)が押された場合
    {
      pressed = false;
      x = 0;
      xmin = 0;
      xmax = 60;
      display2 = true;
      j++;
      Serial.println("画面切り替え");
      delay(3000);
      tft.fillScreen(TFT_BLACK);
      delay(1000);
      fontDump(160, 10, "湿度", 20);
      fontDump(0, 10, "湿度[％]", 16);
      break;
    }
  }

  while (j == 3) // 液晶ディスプレイ(ILI9341)に表示される4番目に表示される画面(CO2濃度のグラフを表示)
  {
    sensor_start();
    checkTouched();

    if (WiFi.status() != WL_CONNECTED) // WiFiに繋がっていない場合(アクセスポイント作成時)
    {
      webSocket.loop();
      webServer.handleClient();
      // 一定の周期でセンシング
      if (sensorElapsed > DELAY)
      {
        sensorElapsed = 0;
        sensor_loop();
      }
      delay(1000);
    }
    else // WiFiに繋がっている場合
    {
      line_message();
    }
    
    //グラフを表示
    if (x < xmax)
    {
      x++;
    }
    else
    {
      xmin = xmax;
      xmax = xmax + 60;
      display3 = true;
      tft.fillScreen(TFT_BLACK);
      delay(500);
      fontDump(160, 10, "湿度", 20);
      fontDump(0, 10, "湿度[％]", 16);
    }
    if (x == 240)
    {
      x = 0;
      xmin = 0;
      xmax = 60;
      display3 = true;
      tft.fillScreen(TFT_BLACK);
      fontDump(160, 10, "湿度", 20);
      fontDump(0, 10, "湿度[％]", 16);
    }
    Graph(x, humid, 30, 210, 270, 180, xmin, xmax, 10, 0, 100, 10, "", " Time [s]", "", TFT_DARKGREY, TFT_RED, TFT_GREEN, TFT_WHITE, TFT_BLACK, display3);

    if (sensorValue < 2250 || pressed) // 感圧センサか液晶ディスプレイ(ILI9341)が押された場合
    {
      pressed = false;
      x = 0;
      xmin = 0;
      xmax = 60;
      display3 = true;
      j = 0;
      Serial.println("画面切り替え");
      delay(3000);
      tft.fillScreen(TFT_BLACK);
      break;
    }
  }
}